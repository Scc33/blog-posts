<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>How to Solve the Valid Parentheses Leetcode Problem</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">How to Solve the Valid Parentheses Leetcode Problem</h1>
</header>
<section data-field="subtitle" class="p-summary">
Mastering the Art of String Validation: A Guide to Check the Validity of Parentheses, Brackets, and Braces.
</section>
<section data-field="body" class="e-content">
<section name="ef47" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="04cd" id="04cd" class="graf graf--h3 graf--leading graf--title">How to Solve the Valid Parentheses Leetcode Problem</h3><h4 name="9aab" id="9aab" class="graf graf--h4 graf-after--h3 graf--subtitle">Mastering the Art of String Validation: A Guide to Check the Validity of Parentheses, Brackets, and Braces.</h4><figure name="d4f5" id="d4f5" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="0*FAW7_ZALImvhT0d_" data-width="1200" data-height="630" data-is-featured="true" alt="Math symbols" src="https://cdn-images-1.medium.com/max/800/0*FAW7_ZALImvhT0d_"><figcaption class="imageCaption">Generated by AI</figcaption></figure><h3 name="a0c6" id="a0c6" class="graf graf--h3 graf-after--figure">The Problem</h3><p name="ae3b" id="ae3b" class="graf graf--p graf-after--h3">With this article, I will be covering the <a href="https://leetcode.com/problems/valid-parentheses/description/" data-href="https://leetcode.com/problems/valid-parentheses/description/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Leetcode Valid Parentheses problem</a>. Leetcode describes the problem with the following.</p><blockquote name="85fe" id="85fe" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.</em></blockquote><blockquote name="0bab" id="0bab" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">An input string is valid if:</em></blockquote><blockquote name="00ef" id="00ef" class="graf graf--blockquote graf-after--blockquote">Open brackets must be closed by the same type of brackets.</blockquote><blockquote name="a354" id="a354" class="graf graf--blockquote graf-after--blockquote">Open brackets must be closed in the correct order.</blockquote><blockquote name="7aae" id="7aae" class="graf graf--blockquote graf-after--blockquote">Every close bracket has a corresponding open bracket of the same type.</blockquote><p name="dcf1" id="dcf1" class="graf graf--p graf-after--blockquote">One key note in the problem description is that the string <code class="markup--code markup--p-code">s</code> will only contain parenthesis-type characters. This simplification makes the problem easier because we only need to worry about six characters and don&#39;t have any concerns with trimming or stripping out irrelevant characters.</p><p name="3476" id="3476" class="graf graf--p graf-after--p">With this problem, and with most coding challenges, I followed a three-step process:</p><ol class="postList"><li name="90ac" id="90ac" class="graf graf--li graf-after--p">First, I like to understand the problem with an incorrect solution</li><li name="5ba6" id="5ba6" class="graf graf--li graf-after--li">Then I’ll determine a solution that works</li><li name="53f2" id="53f2" class="graf graf--li graf-after--li">Finally, I’ll optimize that solution to be fast and clean</li></ol><p name="835c" id="835c" class="graf graf--p graf-after--li">With that framework, let’s get into tackling this problem using Python.</p><h3 name="ca7c" id="ca7c" class="graf graf--h3 graf-after--p">Solution 1 — Getting Things Wrong</h3><p name="9fa1" id="9fa1" class="graf graf--p graf-after--h3">My kneejerk reaction was to count the number of parenthesis types. Since every opening parenthesis type will need a corresponding closing parenthesis, the counts need to be equal.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="5cfe" id="5cfe" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># Note - this doesn&#x27;t work</span><br /><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s</span>):<br />        stack = []<br />        <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> s:<br />            stack.append(letter)<br />        forwardParen = <span class="hljs-number">0</span><br />        backwardParen = <span class="hljs-number">0</span><br />        forwardCurly = <span class="hljs-number">0</span><br />        backwardCurly = <span class="hljs-number">0</span><br />        forwardSquare = <span class="hljs-number">0</span><br />        backwardSquare = <span class="hljs-number">0</span><br />        <span class="hljs-keyword">while</span> stack:<br />            letter = stack.pop()<br />            <span class="hljs-keyword">if</span> letter == <span class="hljs-string">&#x27;(&#x27;</span>:<br />                forwardParen += <span class="hljs-number">1</span><br />            <span class="hljs-keyword">elif</span> letter == <span class="hljs-string">&#x27;)&#x27;</span>:<br />                backwardParen += <span class="hljs-number">1</span><br />            <span class="hljs-keyword">elif</span> letter == <span class="hljs-string">&#x27;{&#x27;</span>:<br />                forwardCurly += <span class="hljs-number">1</span><br />            <span class="hljs-keyword">elif</span> letter == <span class="hljs-string">&#x27;}&#x27;</span>:<br />                backwardCurly += <span class="hljs-number">1</span><br />            <span class="hljs-keyword">elif</span> letter == <span class="hljs-string">&#x27;[&#x27;</span>:<br />                forwardSquare += <span class="hljs-number">1</span><br />            <span class="hljs-keyword">else</span>:<br />                backwardSquare += <span class="hljs-number">1</span><br />        valid = forwardParen == backwardParen <span class="hljs-keyword">and</span> forwardCurly == backwardCurly <span class="hljs-keyword">and</span> forwardSquare == backwardSquare<br />        <span class="hljs-keyword">return</span> valid <span class="hljs-comment"># this solution will not work</span></span></pre><p name="5ad3" id="5ad3" class="graf graf--p graf-after--pre">This is a nice starting point, however, this solution is inaccurate. An example like <code class="markup--code markup--p-code">[(])</code> has an equivalent number of each type, but the alignment of those types does not form a valid set of parentheses.</p><p name="4679" id="4679" class="graf graf--p graf-after--p">Coming up with an incorrect solution is an <em class="markup--em markup--p-em">okay</em> way to start. An incorrect solution is often a good way to organize thoughts, understand the problem better, and rule out possibilities. From an incorrect solution, we can continue to optimize until we have something correct. Then from a correct solution, we can optimize further until we have a fast solution.</p><p name="1130" id="1130" class="graf graf--p graf-after--p">In this incorrect first step, I came across the kernel of understanding that leads to a solution. A stack.</p><h3 name="64be" id="64be" class="graf graf--h3 graf-after--p">Solution 2 — Finding the Answer</h3><p name="5673" id="5673" class="graf graf--p graf-after--h3">The stack data structure will allow us to maintain the ordering of the characters in the string. For our stack, we will append each forward character. For example, <code class="markup--code markup--p-code">[({})]</code> would produce:</p><ol class="postList"><li name="c1ba" id="c1ba" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">{</code></li><li name="23e2" id="23e2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(</code></li><li name="764f" id="764f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">[</code></li></ol><p name="c7a2" id="c7a2" class="graf graf--p graf-after--li">For any non-forward characters, we will pop the stack and compare if there is a match between our position in the string and the character in the stack we can continue onwards. If there is a mismatch then we know this isn’t valid, and we can return false.</p><p name="c452" id="c452" class="graf graf--p graf-after--p">Using our previous example. The <code class="markup--code markup--p-code">}</code> matches the <code class="markup--code markup--p-code">{</code> on the top of the stack. Then <code class="markup--code markup--p-code">)</code> matches the <code class="markup--code markup--p-code">(</code> that follows on the stack. And finally, <code class="markup--code markup--p-code">]</code> matches <code class="markup--code markup--p-code">[</code> which is the last value in the stack. Since the stack is empty we know we have a valid string.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="d150" id="d150" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s</span>):<br />        stack = []<br />        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br />            <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">or</span> i == <span class="hljs-string">&#x27;{&#x27;</span> <span class="hljs-keyword">or</span> i == <span class="hljs-string">&#x27;[&#x27;</span>:<br />                stack.append(i)<br />            <span class="hljs-keyword">else</span>:<br />                <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span>:<br />                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br />                <span class="hljs-keyword">else</span>:<br />                    value = stack.pop()<br />                    <span class="hljs-keyword">if</span> value == <span class="hljs-string">&#x27;(&#x27;</span> <span class="hljs-keyword">and</span> i != <span class="hljs-string">&#x27;)&#x27;</span>:<br />                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br />                    <span class="hljs-keyword">elif</span> value == <span class="hljs-string">&#x27;{&#x27;</span> <span class="hljs-keyword">and</span> i != <span class="hljs-string">&#x27;}&#x27;</span>:<br />                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br />                    <span class="hljs-keyword">elif</span> value == <span class="hljs-string">&#x27;[&#x27;</span> <span class="hljs-keyword">and</span> i != <span class="hljs-string">&#x27;]&#x27;</span>:<br />                        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br />        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span></span></pre><h3 name="4404" id="4404" class="graf graf--h3 graf-after--pre">Final Optimized Solution</h3><p name="034f" id="034f" class="graf graf--p graf-after--h3">I think the second solution is good, however, we can do better by incorporating a dictionary. Using a dictionary will allow for the compression of all the messy conditional logic into one simple check using the <code class="markup--code markup--p-code">in</code> keyword.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="d0c0" id="d0c0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">self, s</span>):<br />        parens = {<span class="hljs-string">&#x27;(&#x27;</span>:<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;{&#x27;</span>:<span class="hljs-string">&#x27;}&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>:<span class="hljs-string">&#x27;]&#x27;</span>}<br />        stack = []<br />        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:<br />            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> parens:<br />                stack.append(i)<br />            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> parens[stack.pop()] != i:<br />                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br />        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span></span></pre><p name="7fcf" id="7fcf" class="graf graf--p graf-after--pre">First, define a dictionary containing forward parentheses as the key and backward parentheses as the value. Once again we will also need a stack.</p><p name="780b" id="780b" class="graf graf--p graf-after--p">Once we have the dictionary and a stack we can start our iteration over the string. If a character is in the dictionary then we add that to the stack. Here a character being in the dictionary implies that it is a forward character. If a character doesn’t fit that description we drop to that second conditional.</p><p name="493f" id="493f" class="graf graf--p graf-after--p">The first condition in the elif covers cases when there is no opening character to a backward. For example, <code class="markup--code markup--p-code">))))))</code> has all backward characters and no forward characters. That will cause the stack to be empty, and then we know that this would not be a valid string.</p><p name="74d2" id="74d2" class="graf graf--p graf-after--p">The second condition in the elif covers mismatches in the ordering. For example, <code class="markup--code markup--p-code">{(})[]</code> has the correct number of forward and backward characters, but the ordering isn&#39;t valid. Here the <code class="markup--code markup--p-code">{</code> would be added to the stack and then <code class="markup--code markup--p-code">(</code> would follow. However, once we hit <code class="markup--code markup--p-code">}</code> then <code class="markup--code markup--p-code">(</code> would be popped from the stack. That does not match, so we bomb out and return false.</p><p name="18d3" id="18d3" class="graf graf--p graf-after--p">Finally, we return if the stack is empty or not. For example, the string <code class="markup--code markup--p-code">{</code> doesn&#39;t have a closing counterpart, so the stack would not be empty and that would not be a valid string. And that&#39;s it, the solution is complete!</p><h3 name="89d8" id="89d8" class="graf graf--h3 graf-after--p">Big O Calculation</h3><p name="1f20" id="1f20" class="graf graf--p graf-after--h3">Lookups in our dictionary are <em class="markup--em markup--p-em">O(1)</em>. Appending to and popping from the array, which we are using as the underlying data structure for the stack, is also <a href="https://stackoverflow.com/questions/195625/what-is-the-time-complexity-of-popping-elements-from-list-in-python" data-href="https://stackoverflow.com/questions/195625/what-is-the-time-complexity-of-popping-elements-from-list-in-python" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">O(1)</em></a>. We loop over the entire string so that is <em class="markup--em markup--p-em">O(n)</em>. Therefore the overall runtime is <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">O(n)</em></strong>.</p><h3 name="ad1b" id="ad1b" class="graf graf--h3 graf-after--p">Where to Learn More</h3><p name="b691" id="b691" class="graf graf--p graf-after--h3">You can also read more interview prep with my <a href="https://blog.seancoughlin.me/series/interview-prep" data-href="https://blog.seancoughlin.me/series/interview-prep" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">series on SWE interviewing</a>.</p><p name="5a8e" id="5a8e" class="graf graf--p graf-after--p graf--trailing">The cover image was generated using <a href="https://openai.com/product/dall-e-2" data-href="https://openai.com/product/dall-e-2" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dalle2</a> and the prompt “create an image incorporating mathematical symbols and a lot of parentheses in an impressionist style.”</p></div></div></section><section name="72e3" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="bce2" id="bce2" class="graf graf--p graf--leading graf--trailing"><em class="markup--em markup--p-em">Originally published at </em><a href="https://blog.seancoughlin.me/how-to-determine-valid-parentheses" data-href="https://blog.seancoughlin.me/how-to-determine-valid-parentheses" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">https://blog.seancoughlin.me</em></a><em class="markup--em markup--p-em">.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@sean-coughlin" class="p-author h-card">Sean Coughlin</a> on <a href="https://medium.com/p/66a661c8711b"><time class="dt-published" datetime="2023-04-08T19:29:32.258Z">April 8, 2023</time></a>.</p><p><a href="https://medium.com/@sean-coughlin/how-to-solve-the-valid-parentheses-leetcode-problem-66a661c8711b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 7, 2024.</p></footer></article></body></html>