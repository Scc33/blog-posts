<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Find the Index of the First Occurrence in a String (Naive and KMP Solutions)</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Find the Index of the First Occurrence in a String (Naive and KMP Solutions)</h1>
</header>
<section data-field="subtitle" class="p-summary">
Learn how to improve string matching efficiency with the Knuth-Morris-Pratt (KMP) algorithm.
</section>
<section data-field="body" class="e-content">
<section name="5f73" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="93c7" id="93c7" class="graf graf--h3 graf--leading graf--title">Find the Index of the First Occurrence in a String (Naive and KMP Solutions)</h3><p name="b2ae" id="b2ae" class="graf graf--p graf-after--h3">Learn how to improve string matching efficiency with the Knuth-Morris-Pratt (KMP) algorithm.</p><figure name="d63b" id="d63b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*oS2CtY2RItHzVIl_AaRQLw.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*oS2CtY2RItHzVIl_AaRQLw.png"><figcaption class="imageCaption">Binary text generated by DallE2</figcaption></figure><h3 name="12d4" id="12d4" class="graf graf--h3 graf-after--figure">Problem</h3><p name="e743" id="e743" class="graf graf--p graf-after--h3">Let’s take a look at the problem <a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/" data-href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Find the Index of the First Occurance in a String</a>.</p><p name="5830" id="5830" class="graf graf--p graf-after--p">In this problem, you have two strings: a needle and a haystack. The goal is to return the index of the needle in the haystack or -1 if the needle does not exist in the haystack.</p><p name="a5ab" id="a5ab" class="graf graf--p graf-after--p">This is a Leetcode easy-level problem. I think the naive solution fits that definition, however as you will see, the faster runtime solution requires some heavy lifting. That solution makes it feels more like a medium problem to me.</p><p name="6cb5" id="6cb5" class="graf graf--p graf-after--p">I’ll be tackling this problem using Python.</p><h3 name="2ba7" id="2ba7" class="graf graf--h3 graf-after--p">Naive Solution</h3><p name="1139" id="1139" class="graf graf--p graf-after--h3">First, let’s consider the naive solution. At the very basic level, we can use the <a href="https://www.w3schools.com/python/ref_string_find.asp" data-href="https://www.w3schools.com/python/ref_string_find.asp" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">built-in find function</a>.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="4732" id="4732" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):<br />            <span class="hljs-keyword">return</span> haystack.find(needle)</span></pre><p name="8df6" id="8df6" class="graf graf--p graf-after--pre">If you don’t have access to <em class="markup--em markup--p-em">find</em> or are a Python warrior and want to grind things out, then you could implement the following.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="897a" id="897a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):<br />        searchLen = <span class="hljs-built_in">len</span>(needle)<br />        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(haystack)):<br />            <span class="hljs-keyword">if</span> haystack[i:i+searchLen] == needle:<br />                <span class="hljs-keyword">return</span> i<br />        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></span></pre><p name="006c" id="006c" class="graf graf--p graf-after--pre">This line uses string slicing to extract a substring of length <code class="markup--code markup--p-code">searchLen</code> starting at the current index <code class="markup--code markup--p-code">i</code> of the <code class="markup--code markup--p-code">haystack</code> string, and then checks if it matches the <code class="markup--code markup--p-code">needle</code> string. If there&#39;s a match, the function returns the current index <code class="markup--code markup--p-code">i</code>. If we reach the end of the <code class="markup--code markup--p-code">haystack</code> then we return <code class="markup--code markup--p-code">-1</code> as the needle was not found.</p><h4 name="92e4" id="92e4" class="graf graf--h4 graf-after--p">Naive Solution Runtime</h4><p name="2f10" id="2f10" class="graf graf--p graf-after--h4">Assume <em class="markup--em markup--p-em">m</em> is the length of the haystack and <em class="markup--em markup--p-em">n</em> is the length of the needle. We are looping over the entire length of the haystack giving at least <em class="markup--em markup--p-em">O(m).</em> In each iteration, we are taking a substring and comparing it to the needle which gives O( <em class="markup--em markup--p-em">n)</em>. Therefore, the overall time complexity of this Naive solution is .</p><h3 name="ec5b" id="ec5b" class="graf graf--h3 graf-after--p">KMP Solution</h3><p name="5c01" id="5c01" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">O(mn)</em> isn’t a very good solution and we can certainly do better by using an algorithm known as Knuth-Morris-Pratt or simply KMP. Before diving into code, it is helpful to understand what KMP is, so let’s look at some definitions.</p><p name="5e4f" id="5e4f" class="graf graf--p graf-after--p">ChatGPT describes KMP as the following.</p><blockquote name="1a87" id="1a87" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">The Knuth-Morris-Pratt (KMP) algorithm is a string-matching algorithm that searches for occurrences of a pattern within a longer text. It was developed by Donald Knuth, Vaughan Pratt, and James Morris in 1977.</em></blockquote><blockquote name="3b4b" id="3b4b" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">The KMP algorithm uses a pre-processing step to build a partial match table, which is used to determine the largest possible suffix of the pattern that matches a prefix of the text. This information is then used to avoid unnecessary comparisons when searching for occurrences of the pattern within the text.</em></blockquote><blockquote name="40e8" id="40e8" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">The KMP algorithm has a time complexity of O(m + n), where m is the length of the pattern and n is the length of the text. This makes it more efficient than other string-matching algorithms such as the naive algorithm, which has a time complexity of O(m * n).</em></blockquote><blockquote name="f1f7" id="f1f7" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">Overall, the KMP algorithm is a useful tool for applications such as text search, data compression, and bioinformatics.</em></blockquote><p name="d5f7" id="d5f7" class="graf graf--p graf-after--blockquote">Thank you GPT. However, I prefer <a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" data-href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Wikipedia’s more succinct KMP description</a>.</p><blockquote name="9bb3" id="9bb3" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">[KMP Algorithm] searches for occurrences of a “word” </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">W</em></code><em class="markup--em markup--blockquote-em"> within a main &quot;text string&quot; </em><code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">S</em></code><em class="markup--em markup--blockquote-em"> by employing the observation that when a mismatch occurs, the word itself embodies sufficient information to determine where the next match could begin, thus bypassing re-examination of previously matched characters.</em></blockquote><p name="f261" id="f261" class="graf graf--p graf-after--blockquote">Finally, let’s consider one last definition from <a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/" data-href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">GeeksForGeeks</a>.</p><blockquote name="97d3" id="97d3" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">The basic idea behind KMP’s algorithm is: whenever we detect a mismatch (after some matches), we already know some of the characters in the text of the next window. We take advantage of this information to avoid matching the characters that we know will anyway match.</em></blockquote><p name="dcd1" id="dcd1" class="graf graf--p graf-after--blockquote">Equipped with these three definitions of KMP we can begin to see this technique offers a speed-up because we avoid unnecessary comparisons on each iteration over the haystack.</p><p name="16dc" id="16dc" class="graf graf--p graf-after--p">The key leverage point needed to make this speed up is that we will use a helper array to do prefix and suffix matching.</p><h4 name="fe8b" id="fe8b" class="graf graf--h4 graf-after--p">KMP Implementation</h4><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="d053" id="d053" class="graf graf--pre graf-after--h4 graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strStr</span>(<span class="hljs-params">self, haystack, needle</span>):<br />        needleLen = <span class="hljs-built_in">len</span>(needle)<br />        haystackLen = <span class="hljs-built_in">len</span>(haystack)<br />        i = <span class="hljs-number">1</span><br />        j = <span class="hljs-number">0</span><br />        patternArr = [-<span class="hljs-number">1</span>] + [<span class="hljs-number">0</span>] * needleLen<br />        <span class="hljs-keyword">while</span> i &lt; needleLen:            <span class="hljs-comment"># calculate helper array</span><br />            <span class="hljs-keyword">if</span> j == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> needle[i] == needle[j]:   <br />                i += <span class="hljs-number">1</span><br />                j += <span class="hljs-number">1</span><br />                patternArr[i] = j<br />            <span class="hljs-keyword">else</span>:<br />                j = patternArr[j]<br />        i = <span class="hljs-number">0</span><br />        j = <span class="hljs-number">0</span><br />        <span class="hljs-keyword">while</span> i &lt; haystackLen <span class="hljs-keyword">and</span> j &lt; needleLen:  <span class="hljs-comment"># process haystack with helper array</span><br />            <span class="hljs-keyword">if</span> j == -<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> haystack[i] == needle[j]:<br />                i += <span class="hljs-number">1</span><br />                j += <span class="hljs-number">1</span><br />            <span class="hljs-keyword">else</span>:<br />                j = patternArr[j]<br />        <span class="hljs-keyword">if</span> j == needleLen: <br />            <span class="hljs-keyword">return</span> i-j<br />        <span class="hljs-keyword">else</span>: <br />            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span></span></pre><p name="2229" id="2229" class="graf graf--p graf-after--pre">First, we set up the necessary variables including the length of the needle, the length of the haystack, and the pattern array that we will use to speed up matching.</p><p name="e04c" id="e04c" class="graf graf--p graf-after--p">Next, we loop over the needle string. <code class="markup--code markup--p-code">i</code> leads and will always be ahead while <code class="markup--code markup--p-code">j</code> follows (because <code class="markup--code markup--p-code">i</code> starts at one and <code class="markup--code markup--p-code">j</code> starts at zero). If there is a match then we write the value of <code class="markup--code markup--p-code">j</code> into the helper/pattern array at <code class="markup--code markup--p-code">i</code>. You can think of a match as when some part of the suffix is the same as some part of the prefix.</p><p name="737d" id="737d" class="graf graf--p graf-after--p">After populating the helper array we can finally look through the haystack for a match. In this loop, <code class="markup--code markup--p-code">i</code> will represent our place in the haystack and <code class="markup--code markup--p-code">j</code> our position in the needle. I&#39;ve used the same variable names for brevity but you could easily name them something else if that helps you understand and document your code.</p><p name="d430" id="d430" class="graf graf--p graf-after--p">If there is a match between the haystack and the needle we increment both counters, otherwise we reset <code class="markup--code markup--p-code">j</code> to the previous value in the pattern array.</p><p name="2b07" id="2b07" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">j</code> equals the length of the needle then we know we have matched the entire needle. The location of the needle in the haystack is calculated by <code class="markup--code markup--p-code">i-j</code>. Otherwise, if no needle is found and we will return -1 to indicate that there is no match.</p><h4 name="3ea1" id="3ea1" class="graf graf--h4 graf-after--p">Example Execution</h4><p name="0d24" id="0d24" class="graf graf--p graf-after--h4">That is a fairly complex piece of code so let’s set through it to see how the parts are working together.</p><p name="e65a" id="e65a" class="graf graf--p graf-after--p">Suppose we have the needle <code class="markup--code markup--p-code">abac</code> and the haystack of <code class="markup--code markup--p-code">abyabgabac</code>.</p><p name="640f" id="640f" class="graf graf--p graf-after--p">Upon processing the needle we will generate the following helper array.</p><figure name="a685" id="a685" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*sYbJAiSoMH5NOfWS" data-width="232" data-height="92" src="https://cdn-images-1.medium.com/max/800/0*sYbJAiSoMH5NOfWS"></figure><p name="8d68" id="8d68" class="graf graf--p graf-after--figure">The one and two underneath the second <code class="markup--code markup--p-code">ab</code> represent a match between that suffix and the earlier prefix <code class="markup--code markup--p-code">ab</code>. Now we use that array to process the haystack.</p><figure name="5aa5" id="5aa5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*_lFtJDHUFV59g76r" data-width="640" data-height="144" src="https://cdn-images-1.medium.com/max/800/0*_lFtJDHUFV59g76r"></figure><p name="8fdf" id="8fdf" class="graf graf--p graf-after--figure">Notice the <code class="markup--code markup--p-code">i</code> counter variable which is tracking our position in the haystack is monotonically increasing while the <code class="markup--code markup--p-code">j</code> value jumps around. The <code class="markup--code markup--p-code">j</code> value is jumping around because it is tracking how much of a match we have seen. If we reach the end of the haystack and <code class="markup--code markup--p-code">j</code> equals the length of the needle that means we have seen a complete match.</p><p name="2530" id="2530" class="graf graf--p graf-after--p">If you want to see more examples I would recommend adding print statements to the code snippet above. Seeing the output of <code class="markup--code markup--p-code">i</code> and <code class="markup--code markup--p-code">j</code> on different inputs is really helpful for understanding this problem.</p><h4 name="9e66" id="9e66" class="graf graf--h4 graf-after--p">KMP Solution Runtime</h4><p name="062e" id="062e" class="graf graf--p graf-after--h4">Assume <em class="markup--em markup--p-em">m</em> is the length of the haystack and <em class="markup--em markup--p-em">n</em> is the length of the needle. At the start, we calculate the needle suffix array which is <em class="markup--em markup--p-em">O(n).</em> Then we loop over the entire length of the haystack which is <em class="markup--em markup--p-em">O(m).</em> Therefore, the overall time complexity of the KMP solution is <em class="markup--em markup--p-em">O(m + n)</em>.</p><p name="eb3b" id="eb3b" class="graf graf--p graf-after--p">By taking this more advanced approach we have sped up the big O runtime from <em class="markup--em markup--p-em">O(mn)</em> to <em class="markup--em markup--p-em">O(m + n)</em>. Not too bad for a day’s work.</p><h3 name="e366" id="e366" class="graf graf--h3 graf-after--p">Where to Learn More</h3><p name="39b7" id="39b7" class="graf graf--p graf-after--h3">If you find video explanations helpful then I would highly recommend <a href="https://www.youtube.com/watch?v=GTJr8OvyEVQ" data-href="https://www.youtube.com/watch?v=GTJr8OvyEVQ" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">this video by Coding Made Simple</a>.</p><p name="490c" id="490c" class="graf graf--p graf-after--p">You can also read more interview prep with my <a href="https://blog.seancoughlin.me/series/interview-prep" data-href="https://blog.seancoughlin.me/series/interview-prep" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">series on SWE interviewing</a>.</p><p name="e700" id="e700" class="graf graf--p graf-after--p graf--trailing">The cover image was generated using <a href="https://openai.com/product/dall-e-2" data-href="https://openai.com/product/dall-e-2" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dalle2</a> and the prompt “binary on a computer screen.”</p></div></div></section><section name="7e82" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="eb55" id="eb55" class="graf graf--p graf--leading graf--trailing"><em class="markup--em markup--p-em">Originally published at </em><a href="https://blog.seancoughlin.me/find-the-index-of-the-first-occurrence-in-a-string-naive-and-kmp-solutions" data-href="https://blog.seancoughlin.me/find-the-index-of-the-first-occurrence-in-a-string-naive-and-kmp-solutions" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">https://blog.seancoughlin.me</em></a><em class="markup--em markup--p-em">.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@sean-coughlin" class="p-author h-card">Sean Coughlin</a> on <a href="https://medium.com/p/a7f2a24b0fe9"><time class="dt-published" datetime="2023-04-05T21:06:27.318Z">April 5, 2023</time></a>.</p><p><a href="https://medium.com/@sean-coughlin/inarindex-first-occurrence-in-string-a7f2a24b0fe9" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on March 7, 2024.</p></footer></article></body></html>